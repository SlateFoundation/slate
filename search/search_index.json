{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome \u00b6 Welcome, browse sections at the top of the site.","title":"Welcome"},{"location":"#welcome","text":"Welcome, browse sections at the top of the site.","title":"Welcome"},{"location":"development/","text":"Development \u00b6 The Development section provides content covering: Overviews of the internal architecture and components Obtaining development environments Executing development workflows Feature implementation guides and examples","title":"Development"},{"location":"development/#development","text":"The Development section provides content covering: Overviews of the internal architecture and components Obtaining development environments Executing development workflows Feature implementation guides and examples","title":"Development"},{"location":"development/email/","text":"Working with Email \u00b6 Catching emails in development \u00b6 In the studio, you can enable relaying email to a specified SMTP endpoint. HELO and mailtrap are easy SMTP endpoints to set up for development that provide UIs for reviewing emails sent to all recipients. When emails are configured to be relayed to these services, they will be trapped for review and never actually delivered to anyone externally, no matter what recipients you use. As opposed to overriding recipient emails to test email features, this approach enables you to verify that personalized bulk emails send the right content to the right recipients. Using HELO \u00b6 Download and open the HELO app Launch studio, run start-all Install and activate postfix email backend: enable-email Configure postfix email backend to relay to EHLO app on Docker host machine: enable-email-relay host.docker.internal 2525 studio Or, using mailtrap: enable-email-relay smtp.mailtrap.io 2525 mailtrapusername mailtrappassword Sending a test email \u00b6 From the studio: Install netcat: hab pkg install --binlink core/netcat Open SMTP connection: nc localhost 25 Start SMTP session: EHLO localhost.localdomain Set sender: MAIL FROM: <sender@example.com> Set recipient: RCPT TO: <recipient@example.com> Set message: DATA Subject: Hello world! This is the body of my email. Have a good day. . Close SMTP session: QUIT Review postfix backend log: less -S /hab/cache/sys.log","title":"Working with Email"},{"location":"development/email/#working-with-email","text":"","title":"Working with Email"},{"location":"development/email/#catching-emails-in-development","text":"In the studio, you can enable relaying email to a specified SMTP endpoint. HELO and mailtrap are easy SMTP endpoints to set up for development that provide UIs for reviewing emails sent to all recipients. When emails are configured to be relayed to these services, they will be trapped for review and never actually delivered to anyone externally, no matter what recipients you use. As opposed to overriding recipient emails to test email features, this approach enables you to verify that personalized bulk emails send the right content to the right recipients.","title":"Catching emails in development"},{"location":"development/email/#using-helo","text":"Download and open the HELO app Launch studio, run start-all Install and activate postfix email backend: enable-email Configure postfix email backend to relay to EHLO app on Docker host machine: enable-email-relay host.docker.internal 2525 studio Or, using mailtrap: enable-email-relay smtp.mailtrap.io 2525 mailtrapusername mailtrappassword","title":"Using HELO"},{"location":"development/email/#sending-a-test-email","text":"From the studio: Install netcat: hab pkg install --binlink core/netcat Open SMTP connection: nc localhost 25 Start SMTP session: EHLO localhost.localdomain Set sender: MAIL FROM: <sender@example.com> Set recipient: RCPT TO: <recipient@example.com> Set message: DATA Subject: Hello world! This is the body of my email. Have a good day. . Close SMTP session: QUIT Review postfix backend log: less -S /hab/cache/sys.log","title":"Sending a test email"},{"location":"development/migrations/","text":"Developing Migrations \u00b6 Within the development studio: Create a new file under php-migrations/ Load modified working tree into runtime: update-site Execute all migrations: console-run migrations:execute --all (Re)Execute a specific migration: console-run migrations:execute --force \"Emergence/People/20191209_system-user\"","title":"Developing Migrations"},{"location":"development/migrations/#developing-migrations","text":"Within the development studio: Create a new file under php-migrations/ Load modified working tree into runtime: update-site Execute all migrations: console-run migrations:execute --all (Re)Execute a specific migration: console-run migrations:execute --force \"Emergence/People/20191209_system-user\"","title":"Developing Migrations"},{"location":"development/running-tests/e2e/","text":"End-to-end (E2E) testing \u00b6 Cypress is used to provide browser-level full-stack testing. In this project, Cypress gets run within the cypress-workspace holobranch defined at .holo/branch/cypress-workspace/** within the project repository. This allows local test suite additions and overrides to be stacked on top of those provided by parent projects. The base implemenation is published from emergence-skeleton and your local project may have any number of parent projects stacked in between, so there can be many layers contributing to the below content structure. The cypress-workspace holobranch typically copies the following overrides from the local project repository: cypress.json : top-level project configuration for cypress cypress/integrations/**/*.js : additional or overridden test suites cypress/integrations/**/*.json : additional or overridden test suite configurations (provides some flexibility for test suites to support different downstream reskinnings without all their code needing to be duplicated and overridden) cypress/fixtures/** : static content test suites can make use of Less commonly, the following files might also be copied from the local project repository to override the Cypress setup in more depth: cypress/support/index.js : Cypress plugins and additional commands get loaded here for all test suites package.json / package-lock.json : Tracks the Cypress version and those of installed plugin packages Try to avoid having copies of these in local project repositories: cypress/support/commands.js : Base set of additional commands that test suites can rely on. Instead of overridding this file, add additional project-specific commands to some new files under cypress/support and override cypress/support/index.js to load them cypress/plugins/index.js : Base set of automatic environment setup logic Run tests quickly \u00b6 To quickly run the full test suite headlessly, run on the local terminal outside the studio in the root of your local project repository: script/test Run tests interactively \u00b6 To run tests with Cypress\u2019 interactive GUI open, run on the local terminal outside the studio in the root of your local project repository: script/test-interactive This script uses unionfs-fuse to set up a virtual directory mount on your workstation\u2019s filesystem to run Cypress out of. This union mount provides a live workspace where your local project workspace is merged on top of the base set of cypress-workspace content pulled from your parent project. This virtual directory mount gets set up at ${path_to_your_repo}.cypress-workspace/merged and Cypress gets run from there. Changes you save to Cypress content in your local project work tree will immediately be reflected in the merged mount The filesystem events needed to drive auto-reload may not work Exit the Cypress GUI and reload it to thoroughly force your latest content to be used Changes you save to Cypress content in your local merged mount will immediately be reflected back to your local project work tree If parent project content changes / you\u2019ve edited a source config, exit the Cypress GUI and re-run script/test-interactive to restart in a fresh environment Making Cypress auto-reload as you save changes Because filesystem change events from your local project work tree to the merged unionfs that Cypress runs out of don\u2019t always work, work on Cypress tests out of the merged mount instead. Any changes you make will immediately be written to to your local project work tree ready to stage into a git commit, and filesystem change events will fire live for Cypress to auto-reload test suites as you work. The Open in IDE button that Cypress\u2019 main window will how you as you hover over tests in the list can be used to open the copy of the file in the merged mount where changes will trigger auto-reload. Testing against a remote server \u00b6 By setting environment variables before launching the Cypress GUI, the E2E test suite can be configured to execute against a backend studio hosted on a remote machine or server. On the local terminal outside the studio in the root of your local project repository: Set base URL to studo HTTP root reachable from local workstation: export CYPRESS_BASE_URL = 'http://workstation.mydomain:5580' Configure the SSH host that the backend studio is running on: export CYPRESS_STUDIO_SSH = 'workstation.mydomain' Your local terminal must be set up to connect to it without password. Configure the name of the Docker container running the backend studio: export CYPRESS_STUDIO_CONTAINER = 'slate-studio' Launch the Cypress GUI: script/test-interactive","title":"End-to-end (E2E) testing"},{"location":"development/running-tests/e2e/#end-to-end-e2e-testing","text":"Cypress is used to provide browser-level full-stack testing. In this project, Cypress gets run within the cypress-workspace holobranch defined at .holo/branch/cypress-workspace/** within the project repository. This allows local test suite additions and overrides to be stacked on top of those provided by parent projects. The base implemenation is published from emergence-skeleton and your local project may have any number of parent projects stacked in between, so there can be many layers contributing to the below content structure. The cypress-workspace holobranch typically copies the following overrides from the local project repository: cypress.json : top-level project configuration for cypress cypress/integrations/**/*.js : additional or overridden test suites cypress/integrations/**/*.json : additional or overridden test suite configurations (provides some flexibility for test suites to support different downstream reskinnings without all their code needing to be duplicated and overridden) cypress/fixtures/** : static content test suites can make use of Less commonly, the following files might also be copied from the local project repository to override the Cypress setup in more depth: cypress/support/index.js : Cypress plugins and additional commands get loaded here for all test suites package.json / package-lock.json : Tracks the Cypress version and those of installed plugin packages Try to avoid having copies of these in local project repositories: cypress/support/commands.js : Base set of additional commands that test suites can rely on. Instead of overridding this file, add additional project-specific commands to some new files under cypress/support and override cypress/support/index.js to load them cypress/plugins/index.js : Base set of automatic environment setup logic","title":"End-to-end (E2E) testing"},{"location":"development/running-tests/e2e/#run-tests-quickly","text":"To quickly run the full test suite headlessly, run on the local terminal outside the studio in the root of your local project repository: script/test","title":"Run tests quickly"},{"location":"development/running-tests/e2e/#run-tests-interactively","text":"To run tests with Cypress\u2019 interactive GUI open, run on the local terminal outside the studio in the root of your local project repository: script/test-interactive This script uses unionfs-fuse to set up a virtual directory mount on your workstation\u2019s filesystem to run Cypress out of. This union mount provides a live workspace where your local project workspace is merged on top of the base set of cypress-workspace content pulled from your parent project. This virtual directory mount gets set up at ${path_to_your_repo}.cypress-workspace/merged and Cypress gets run from there. Changes you save to Cypress content in your local project work tree will immediately be reflected in the merged mount The filesystem events needed to drive auto-reload may not work Exit the Cypress GUI and reload it to thoroughly force your latest content to be used Changes you save to Cypress content in your local merged mount will immediately be reflected back to your local project work tree If parent project content changes / you\u2019ve edited a source config, exit the Cypress GUI and re-run script/test-interactive to restart in a fresh environment Making Cypress auto-reload as you save changes Because filesystem change events from your local project work tree to the merged unionfs that Cypress runs out of don\u2019t always work, work on Cypress tests out of the merged mount instead. Any changes you make will immediately be written to to your local project work tree ready to stage into a git commit, and filesystem change events will fire live for Cypress to auto-reload test suites as you work. The Open in IDE button that Cypress\u2019 main window will how you as you hover over tests in the list can be used to open the copy of the file in the merged mount where changes will trigger auto-reload.","title":"Run tests interactively"},{"location":"development/running-tests/e2e/#testing-against-a-remote-server","text":"By setting environment variables before launching the Cypress GUI, the E2E test suite can be configured to execute against a backend studio hosted on a remote machine or server. On the local terminal outside the studio in the root of your local project repository: Set base URL to studo HTTP root reachable from local workstation: export CYPRESS_BASE_URL = 'http://workstation.mydomain:5580' Configure the SSH host that the backend studio is running on: export CYPRESS_STUDIO_SSH = 'workstation.mydomain' Your local terminal must be set up to connect to it without password. Configure the name of the Docker container running the backend studio: export CYPRESS_STUDIO_CONTAINER = 'slate-studio' Launch the Cypress GUI: script/test-interactive","title":"Testing against a remote server"},{"location":"development/workspace-setup/content-editor/","text":"Content Editor webapp \u00b6 Code layout \u00b6 sencha-workspace/ packages/ emergence-cms/ : Primary location for content editor UI code emr-skeleton-theme/ : The Sencha theme used when rendering the content editor EmergenceContentEditor/ : A thin Sencha application used to make development easier and to provide a build target for generating the theme html-templates/ webapps/EmergenceContentEditor/sencha.tpl : A template for rendering the content editor embedded in the site\u2019s design frame html-templates/blog/blogPostEdit.tpl : A wrapper around sencha.tpl to provide the content editor UI on the blog post edit form html-templates/pages/pageEdit.tpl : A wrapper around sencha.tpl to provide the content editor UI on the page edit form Running live changes \u00b6 The frontend Sencha application needs to be built at least once with the Sencha CMD build tool to scaffold/update a set of loader files. After that, you can just edit files the working tree and reload the browser. The two exceptions where you need to build again are changing the list of packages or changing the list of override files. Before the frontend application can be built to run from live changes, you\u2019ll need to ensure all submodules are initialized: git submodule update --init Then, use the shortcut studio command for building the frontend application: build-content-editor Once built, the live-editable version of the app can be accessed via the static web server that the studio runs on port 5581 . The backend host must be provided to the apps via the ?apiHost query parameter. Any remote backend with CORS enabled will work, or you can use the local backend: localhost:5581/EmergenceContentEditor/?apiHost=localhost:5580 Working with breakpoints \u00b6 By default, the Sencha framework will automatically append random cache buster values to every loaded .js source. This helps ensures that your latest code always runs, but will also prevent any breakpoints you set from persisting across reloads. With the Disable cache option of the network inspector activated, you can disable this built-in cache buster by appending &cache=1 to the current page\u2019s query string. Connecting to remote server \u00b6 You can connect to any remote instance that has CORS enabled by appending the query parameter apiHost when loading the page. If the remote instance requires HTTPS, append apiSSL=1 as well.","title":"Content Editor webapp"},{"location":"development/workspace-setup/content-editor/#content-editor-webapp","text":"","title":"Content Editor webapp"},{"location":"development/workspace-setup/content-editor/#code-layout","text":"sencha-workspace/ packages/ emergence-cms/ : Primary location for content editor UI code emr-skeleton-theme/ : The Sencha theme used when rendering the content editor EmergenceContentEditor/ : A thin Sencha application used to make development easier and to provide a build target for generating the theme html-templates/ webapps/EmergenceContentEditor/sencha.tpl : A template for rendering the content editor embedded in the site\u2019s design frame html-templates/blog/blogPostEdit.tpl : A wrapper around sencha.tpl to provide the content editor UI on the blog post edit form html-templates/pages/pageEdit.tpl : A wrapper around sencha.tpl to provide the content editor UI on the page edit form","title":"Code layout"},{"location":"development/workspace-setup/content-editor/#running-live-changes","text":"The frontend Sencha application needs to be built at least once with the Sencha CMD build tool to scaffold/update a set of loader files. After that, you can just edit files the working tree and reload the browser. The two exceptions where you need to build again are changing the list of packages or changing the list of override files. Before the frontend application can be built to run from live changes, you\u2019ll need to ensure all submodules are initialized: git submodule update --init Then, use the shortcut studio command for building the frontend application: build-content-editor Once built, the live-editable version of the app can be accessed via the static web server that the studio runs on port 5581 . The backend host must be provided to the apps via the ?apiHost query parameter. Any remote backend with CORS enabled will work, or you can use the local backend: localhost:5581/EmergenceContentEditor/?apiHost=localhost:5580","title":"Running live changes"},{"location":"development/workspace-setup/content-editor/#working-with-breakpoints","text":"By default, the Sencha framework will automatically append random cache buster values to every loaded .js source. This helps ensures that your latest code always runs, but will also prevent any breakpoints you set from persisting across reloads. With the Disable cache option of the network inspector activated, you can disable this built-in cache buster by appending &cache=1 to the current page\u2019s query string.","title":"Working with breakpoints"},{"location":"development/workspace-setup/content-editor/#connecting-to-remote-server","text":"You can connect to any remote instance that has CORS enabled by appending the query parameter apiHost when loading the page. If the remote instance requires HTTPS, append apiSSL=1 as well.","title":"Connecting to remote server"},{"location":"development/workspace-setup/local-studio/","text":"Local Studio Container \u00b6 This guide will walk you through launching a Docker-container local development studio and using it to test changes made within a local Git repository. Launch studio container \u00b6 Install Chef Habitat: curl -s https://raw.githubusercontent.com/habitat-sh/habitat/master/components/hab/install.sh | sudo bash Set up Chef Habitat, accepting defaults for all prompts: hab setup Clone slate repository and any submodules: git clone --recursive git@github.com:SlateFoundation/slate.git Change into cloned directory: cd ./slate Launch studio: Use the included scripts-to-rules-them-all workflow script to configure and launch a studio session: script/studio Review the notes printed to your terminal at the end of the studio startup process for a list of all available studio commands. Bootstrap and develop backend \u00b6 Start services: Use the studio command start-all to launch the http server (nginx), the application runtime (php-fpm), and a local mysql server: start-all At this point, you should be able to open localhost:5580 and see the error message Page not found . Build site: To build the entire site and load it, use the studio command update-site : update-site At this point, localhost:5580 should display the current build of the site Load fixture data into site database (optional): load-fixtures The standard fixture data includes the following users: Username Password AccountLevel About system system Developer Full system access admin admin Administrator Manage site and staff teacher teacher Staff Staff access with teaching role in multiple courses sections teacher2 teacher2 Staff Staff access with teaching role in multiple course sections student student User Student user with student role in multiple course sections student2 student2 User Student user with student role in multiple course sections student3 student3 User Student user with no roles in any course sections Make and apply changes: After editing code in the working tree, you must rebuild and update the site: update-site A command to automatically rebuild and update the site as changes are made to the working tree is also available, but currently not that efficient or reliable: watch-site Enable user registration \u00b6 To enable user registration on a site that comes with it disabled: # write class configuring enabling registration mkdir -p php-config/Emergence/People echo '<?php Emergence\\People\\RegistrationRequestHandler::$enableRegistration = true;' > php-config/Emergence/People/RegistrationRequestHandler.config.php # rebuild environment update-site After visiting /register and creating a new user account, you can use the studio command promote-user to upgrade the user account you just registered to the highest access level: promote-user <myuser> Connect to local database \u00b6 The studio container hosts a local MySQL instance that can be connected to at: Host : localhost (or LAN/WAN IP of machine hosting Docker engine) Port : 5536 Username : admin Password : admin","title":"Local Studio Container"},{"location":"development/workspace-setup/local-studio/#local-studio-container","text":"This guide will walk you through launching a Docker-container local development studio and using it to test changes made within a local Git repository.","title":"Local Studio Container"},{"location":"development/workspace-setup/local-studio/#launch-studio-container","text":"Install Chef Habitat: curl -s https://raw.githubusercontent.com/habitat-sh/habitat/master/components/hab/install.sh | sudo bash Set up Chef Habitat, accepting defaults for all prompts: hab setup Clone slate repository and any submodules: git clone --recursive git@github.com:SlateFoundation/slate.git Change into cloned directory: cd ./slate Launch studio: Use the included scripts-to-rules-them-all workflow script to configure and launch a studio session: script/studio Review the notes printed to your terminal at the end of the studio startup process for a list of all available studio commands.","title":"Launch studio container"},{"location":"development/workspace-setup/local-studio/#bootstrap-and-develop-backend","text":"Start services: Use the studio command start-all to launch the http server (nginx), the application runtime (php-fpm), and a local mysql server: start-all At this point, you should be able to open localhost:5580 and see the error message Page not found . Build site: To build the entire site and load it, use the studio command update-site : update-site At this point, localhost:5580 should display the current build of the site Load fixture data into site database (optional): load-fixtures The standard fixture data includes the following users: Username Password AccountLevel About system system Developer Full system access admin admin Administrator Manage site and staff teacher teacher Staff Staff access with teaching role in multiple courses sections teacher2 teacher2 Staff Staff access with teaching role in multiple course sections student student User Student user with student role in multiple course sections student2 student2 User Student user with student role in multiple course sections student3 student3 User Student user with no roles in any course sections Make and apply changes: After editing code in the working tree, you must rebuild and update the site: update-site A command to automatically rebuild and update the site as changes are made to the working tree is also available, but currently not that efficient or reliable: watch-site","title":"Bootstrap and develop backend"},{"location":"development/workspace-setup/local-studio/#enable-user-registration","text":"To enable user registration on a site that comes with it disabled: # write class configuring enabling registration mkdir -p php-config/Emergence/People echo '<?php Emergence\\People\\RegistrationRequestHandler::$enableRegistration = true;' > php-config/Emergence/People/RegistrationRequestHandler.config.php # rebuild environment update-site After visiting /register and creating a new user account, you can use the studio command promote-user to upgrade the user account you just registered to the highest access level: promote-user <myuser>","title":"Enable user registration"},{"location":"development/workspace-setup/local-studio/#connect-to-local-database","text":"The studio container hosts a local MySQL instance that can be connected to at: Host : localhost (or LAN/WAN IP of machine hosting Docker engine) Port : 5536 Username : admin Password : admin","title":"Connect to local database"},{"location":"development/workspace-setup/slate-admin/","text":"SlateAdmin webapp \u00b6 Code layout \u00b6 html-templates/ webapps/SlateAdmin/sencha.tpl : Configuration wrapper for the template that renders the SlateApp when accessed through the site php-classes/ SlateAdmin/ RequestHandler.php : Wrapper that handles authenticating access to SlateAdmin webapp and the loading it WebApp.php : Wrapper SlateAdmin webapp instance that hosts site-level configuration php-config/ Emergence/ WebApps/ App.config.d/ SlateAdmin.php : Registers the SlateAdmin webapp\u2019s custom PHP WebApp wrapper class for its name so that accessing it through /webapps/SlateAdmin will be loaded with the subclass (and the config it hosts) SlateAdmin/ WebApp.config.d/ *.php : Downstream projects can place config snippets here that, for example, register plugins sencha-workspace/ packages/ slate-core-data/ : Shareable model/store/proxy/sorter classes for the Slate namespace slate-theme/ : Shareable theme for Slate apps using the classic UI toolkit slate-ui-classic/ : Shareable UI components for apps using the classic UI toolkit SlateAdmin/ : Entrypoint and all app-specific assets for the SlateAdmin webapp, hosted at /manage on Slate instances site-root/ manage.php : Route that maps /manage to RequestHandler Running live changes \u00b6 The frontend Sencha application needs to be built at least once with the Sencha CMD build tool to scaffold/update a set of loader files. After that, you can just edit files the working tree and reload the browser. The two exceptions where you need to build again are changing the list of packages or changing the list of override files. Before the frontend application can be built to run from live changes, you\u2019ll need to ensure all submodules are initialized: git submodule update --init Then, use the shortcut studio command for building the frontend application: build-admin Once built, the live-editable version of the app can be accessed via the static web server that the studio runs on port 5581 . The backend host must be provided to the apps via the ?apiHost query parameter. Any remote backend with CORS enabled will work, or you can use the local backend: localhost:5581/SlateAdmin/?apiHost=localhost:5580 Working with breakpoints \u00b6 By default, the Sencha framework will automatically append random cache buster values to every loaded .js source. This helps ensures that your latest code always runs, but will also prevent any breakpoints you set from persisting across reloads. With the Disable cache option of the network inspector activated, you can disable this built-in cache buster by appending &cache=1 to the current page\u2019s query string. Connecting to remote server \u00b6 You can connect to any remote instance that has CORS enabled by appending a query parameter in the format ?apiHost=https://slate.example.org when loading the page. A session token may be provided via another query string in the format &apiToken=abcdef1234567890","title":"SlateAdmin webapp"},{"location":"development/workspace-setup/slate-admin/#slateadmin-webapp","text":"","title":"SlateAdmin webapp"},{"location":"development/workspace-setup/slate-admin/#code-layout","text":"html-templates/ webapps/SlateAdmin/sencha.tpl : Configuration wrapper for the template that renders the SlateApp when accessed through the site php-classes/ SlateAdmin/ RequestHandler.php : Wrapper that handles authenticating access to SlateAdmin webapp and the loading it WebApp.php : Wrapper SlateAdmin webapp instance that hosts site-level configuration php-config/ Emergence/ WebApps/ App.config.d/ SlateAdmin.php : Registers the SlateAdmin webapp\u2019s custom PHP WebApp wrapper class for its name so that accessing it through /webapps/SlateAdmin will be loaded with the subclass (and the config it hosts) SlateAdmin/ WebApp.config.d/ *.php : Downstream projects can place config snippets here that, for example, register plugins sencha-workspace/ packages/ slate-core-data/ : Shareable model/store/proxy/sorter classes for the Slate namespace slate-theme/ : Shareable theme for Slate apps using the classic UI toolkit slate-ui-classic/ : Shareable UI components for apps using the classic UI toolkit SlateAdmin/ : Entrypoint and all app-specific assets for the SlateAdmin webapp, hosted at /manage on Slate instances site-root/ manage.php : Route that maps /manage to RequestHandler","title":"Code layout"},{"location":"development/workspace-setup/slate-admin/#running-live-changes","text":"The frontend Sencha application needs to be built at least once with the Sencha CMD build tool to scaffold/update a set of loader files. After that, you can just edit files the working tree and reload the browser. The two exceptions where you need to build again are changing the list of packages or changing the list of override files. Before the frontend application can be built to run from live changes, you\u2019ll need to ensure all submodules are initialized: git submodule update --init Then, use the shortcut studio command for building the frontend application: build-admin Once built, the live-editable version of the app can be accessed via the static web server that the studio runs on port 5581 . The backend host must be provided to the apps via the ?apiHost query parameter. Any remote backend with CORS enabled will work, or you can use the local backend: localhost:5581/SlateAdmin/?apiHost=localhost:5580","title":"Running live changes"},{"location":"development/workspace-setup/slate-admin/#working-with-breakpoints","text":"By default, the Sencha framework will automatically append random cache buster values to every loaded .js source. This helps ensures that your latest code always runs, but will also prevent any breakpoints you set from persisting across reloads. With the Disable cache option of the network inspector activated, you can disable this built-in cache buster by appending &cache=1 to the current page\u2019s query string.","title":"Working with breakpoints"},{"location":"development/workspace-setup/slate-admin/#connecting-to-remote-server","text":"You can connect to any remote instance that has CORS enabled by appending a query parameter in the format ?apiHost=https://slate.example.org when loading the page. A session token may be provided via another query string in the format &apiToken=abcdef1234567890","title":"Connecting to remote server"},{"location":"development/workspace-setup/virtual-multisite/","text":"Virtual Multi-site Container \u00b6 Launch virtual multisite container \u00b6 docker run \\ --name emergence \\ -v emergence:/emergence \\ -p 80 :80 \\ -p 3306 :3306 \\ -p 9083 :9083 \\ jarvus/emergence","title":"Virtual Multi-site Container"},{"location":"development/workspace-setup/virtual-multisite/#virtual-multi-site-container","text":"","title":"Virtual Multi-site Container"},{"location":"development/workspace-setup/virtual-multisite/#launch-virtual-multisite-container","text":"docker run \\ --name emergence \\ -v emergence:/emergence \\ -p 80 :80 \\ -p 3306 :3306 \\ -p 9083 :9083 \\ jarvus/emergence","title":"Launch virtual multisite container"},{"location":"getting-started/","text":"Getting Started \u00b6 The Getting Started section provides content covering: Overviews of the system Obtaining a running instance of the system Configuring a new system for an organization Onboarding new users into the system","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"The Getting Started section provides content covering: Overviews of the system Obtaining a running instance of the system Configuring a new system for an organization Onboarding new users into the system","title":"Getting Started"},{"location":"operations/","text":"Operations \u00b6 The Operations section provides content covering: Overviews of the physical infrastructure and service components Building hosted environments Maintaining hosted environments Backing up and restoring content Monitoring system health","title":"Operations"},{"location":"operations/#operations","text":"The Operations section provides content covering: Overviews of the physical infrastructure and service components Building hosted environments Maintaining hosted environments Backing up and restoring content Monitoring system health","title":"Operations"},{"location":"usage/","text":"Usage \u00b6 The Usage section provides content covering: Overviews of the system features Setting up and customizing a user account Using the system\u2019s features for day-to-day work Reporting and integration","title":"Usage"},{"location":"usage/#usage","text":"The Usage section provides content covering: Overviews of the system features Setting up and customizing a user account Using the system\u2019s features for day-to-day work Reporting and integration","title":"Usage"}]}