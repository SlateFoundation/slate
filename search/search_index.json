{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome \u00b6 Welcome, browse sections at the top of the site.","title":"Welcome"},{"location":"#welcome","text":"Welcome, browse sections at the top of the site.","title":"Welcome"},{"location":"development/email/","text":"Working with Email \u00b6 Catching emails in development \u00b6 In the studio, you can enable relaying email to a specified SMTP endpoint. HELO and mailtrap are easy SMTP endpoints to set up for development that provide UIs for reviewing emails sent to all recipients. When emails are configured to be relayed to these services, they will be trapped for review and never actually delivered to anyone externally, no matter what recipients you use. As opposed to overriding recipient emails to test email features, this approach enables you to verify that personalized bulk emails send the right content to the right recipients. Using HELO \u00b6 Download and open the HELO app Launch studio, run start-all Install and activate postfix email backend: enable-email Configure postfix email backend to relay to EHLO app on Docker host machine: enable-email-relay host.docker.internal 2525 studio Or, using mailtrap: enable-email-relay smtp.mailtrap.io 2525 mailtrapusername mailtrappassword Sending a test email \u00b6 From the studio: Install netcat: hab pkg install --binlink core/netcat Open SMTP connection: nc localhost 25 Start SMTP session: EHLO localhost.localdomain Set sender: MAIL FROM: <sender@example.com> Set recipient: RCPT TO: <recipient@example.com> Set message: DATA Subject: Hello world! This is the body of my email. Have a good day. . Close SMTP session: QUIT Review postfix backend log: less -S /hab/cache/sys.log","title":"Working with Email"},{"location":"development/email/#working-with-email","text":"","title":"Working with Email"},{"location":"development/email/#catching-emails-in-development","text":"In the studio, you can enable relaying email to a specified SMTP endpoint. HELO and mailtrap are easy SMTP endpoints to set up for development that provide UIs for reviewing emails sent to all recipients. When emails are configured to be relayed to these services, they will be trapped for review and never actually delivered to anyone externally, no matter what recipients you use. As opposed to overriding recipient emails to test email features, this approach enables you to verify that personalized bulk emails send the right content to the right recipients.","title":"Catching emails in development"},{"location":"development/email/#using-helo","text":"Download and open the HELO app Launch studio, run start-all Install and activate postfix email backend: enable-email Configure postfix email backend to relay to EHLO app on Docker host machine: enable-email-relay host.docker.internal 2525 studio Or, using mailtrap: enable-email-relay smtp.mailtrap.io 2525 mailtrapusername mailtrappassword","title":"Using HELO"},{"location":"development/email/#sending-a-test-email","text":"From the studio: Install netcat: hab pkg install --binlink core/netcat Open SMTP connection: nc localhost 25 Start SMTP session: EHLO localhost.localdomain Set sender: MAIL FROM: <sender@example.com> Set recipient: RCPT TO: <recipient@example.com> Set message: DATA Subject: Hello world! This is the body of my email. Have a good day. . Close SMTP session: QUIT Review postfix backend log: less -S /hab/cache/sys.log","title":"Sending a test email"},{"location":"development/migrations/","text":"Developing Migrations \u00b6 Within the development studio: Create a new file under php-migrations/ Load modified working tree into runtime: update-site Execute all migrations: console-run migrations:execute --all (Re)Execute a specific migration: console-run migrations:execute --force \"Emergence/People/20191209_system-user\"","title":"Developing Migrations"},{"location":"development/migrations/#developing-migrations","text":"Within the development studio: Create a new file under php-migrations/ Load modified working tree into runtime: update-site Execute all migrations: console-run migrations:execute --all (Re)Execute a specific migration: console-run migrations:execute --force \"Emergence/People/20191209_system-user\"","title":"Developing Migrations"},{"location":"development/getting-started/content-editor/","text":"Content Editor webapp \u00b6 Code layout \u00b6 sencha-workspace/ packages/ emergence-cms/ : Primary location for content editor UI code emr-skeleton-theme/ : The Sencha theme used when rendering the content editor EmergenceContentEditor/ : A thin Sencha application used to make development easier and to provide a build target for generating the theme html-templates/ webapps/EmergenceContentEditor/sencha.tpl : A template for rendering the content editor embedded in the site\u2019s design frame html-templates/blog/blogPostEdit.tpl : A wrapper around sencha.tpl to provide the content editor UI on the blog post edit form html-templates/pages/pageEdit.tpl : A wrapper around sencha.tpl to provide the content editor UI on the page edit form Running live changes \u00b6 The frontend Sencha application needs to be built at least once with the Sencha CMD build tool to scaffold/update a set of loader files. After that, you can just edit files the working tree and reload the browser. The two exceptions where you need to build again are changing the list of packages or changing the list of override files. Before the frontend application can be built to run from live changes, you\u2019ll need to ensure all submodules are initialized: git submodule update --init Then, use the shortcut studio command for building the frontend application: build-content-editor Once built, the live-editable version of the app can be accessed via the static web server that the studio runs on port 7181 . The backend host must be provided to the apps via the ?apiHost query parameter. Any remote backend with CORS enabled will work, or you can use the local backend: localhost:7181/EmergenceContentEditor/?apiHost=localhost:7180 Working with breakpoints \u00b6 By default, the Sencha framework will automatically append random cache buster values to every loaded .js source. This helps ensures that your latest code always runs, but will also prevent any breakpoints you set from persisting across reloads. With the Disable cache option of the network inspector activated, you can disable this built-in cache buster by appending &cache=1 to the current page\u2019s query string. Connecting to remote server \u00b6 You can connect to any remote instance that has CORS enabled by appending the query parameter apiHost when loading the page. If the remote instance requires HTTPS, append apiSSL=1 as well.","title":"Content Editor webapp"},{"location":"development/getting-started/content-editor/#content-editor-webapp","text":"","title":"Content Editor webapp"},{"location":"development/getting-started/content-editor/#code-layout","text":"sencha-workspace/ packages/ emergence-cms/ : Primary location for content editor UI code emr-skeleton-theme/ : The Sencha theme used when rendering the content editor EmergenceContentEditor/ : A thin Sencha application used to make development easier and to provide a build target for generating the theme html-templates/ webapps/EmergenceContentEditor/sencha.tpl : A template for rendering the content editor embedded in the site\u2019s design frame html-templates/blog/blogPostEdit.tpl : A wrapper around sencha.tpl to provide the content editor UI on the blog post edit form html-templates/pages/pageEdit.tpl : A wrapper around sencha.tpl to provide the content editor UI on the page edit form","title":"Code layout"},{"location":"development/getting-started/content-editor/#running-live-changes","text":"The frontend Sencha application needs to be built at least once with the Sencha CMD build tool to scaffold/update a set of loader files. After that, you can just edit files the working tree and reload the browser. The two exceptions where you need to build again are changing the list of packages or changing the list of override files. Before the frontend application can be built to run from live changes, you\u2019ll need to ensure all submodules are initialized: git submodule update --init Then, use the shortcut studio command for building the frontend application: build-content-editor Once built, the live-editable version of the app can be accessed via the static web server that the studio runs on port 7181 . The backend host must be provided to the apps via the ?apiHost query parameter. Any remote backend with CORS enabled will work, or you can use the local backend: localhost:7181/EmergenceContentEditor/?apiHost=localhost:7180","title":"Running live changes"},{"location":"development/getting-started/content-editor/#working-with-breakpoints","text":"By default, the Sencha framework will automatically append random cache buster values to every loaded .js source. This helps ensures that your latest code always runs, but will also prevent any breakpoints you set from persisting across reloads. With the Disable cache option of the network inspector activated, you can disable this built-in cache buster by appending &cache=1 to the current page\u2019s query string.","title":"Working with breakpoints"},{"location":"development/getting-started/content-editor/#connecting-to-remote-server","text":"You can connect to any remote instance that has CORS enabled by appending the query parameter apiHost when loading the page. If the remote instance requires HTTPS, append apiSSL=1 as well.","title":"Connecting to remote server"},{"location":"development/getting-started/local-studio/","text":"Local Studio Container \u00b6 This guide will walk you through launching a Docker-container local development studio and using it to test changes made within a local Git repository. Launch studio container \u00b6 Install Chef Habitat: curl -s https://raw.githubusercontent.com/habitat-sh/habitat/master/components/hab/install.sh | sudo bash Set up Chef Habitat, accepting defaults for all prompts: hab setup Clone slate repository and any submodules: git clone --recursive git@github.com:SlateFoundation/slate.git Change into cloned directory: cd ./slate Launch studio: Use the included scripts-to-rules-them-all workflow script to configure and launch a studio session: script/studio Review the notes printed to your terminal at the end of the studio startup process for a list of all available studio commands. Bootstrap and develop backend \u00b6 Start services: Use the studio command start-all to launch the http server (nginx), the application runtime (php-fpm), and a local mysql server: start-all At this point, you should be able to open localhost:7180 and see the error message Page not found . Build site: To build the entire site and load it, use the studio command update-site : update-site At this point, localhost:7180 should display the current build of the site Load fixture data into site database (optional): load-fixtures The standard fixture data includes the following users: Username Password AccountLevel About system system Developer Full system access admin admin Administrator Manage site and staff teacher teacher Staff Staff access with teaching role in multiple courses sections teacher2 teacher2 Staff Staff access with teaching role in multiple course sections student student User Student user with student role in multiple course sections student2 student2 User Student user with student role in multiple course sections student3 student3 User Student user with no roles in any course sections Make and apply changes: After editing code in the working tree, you must rebuild and update the site: update-site A command to automatically rebuild and update the site as changes are made to the working tree is also available, but currently not that efficient or reliable: watch-site Enable user registration \u00b6 To enable user registration on a site that comes with it disabled: # write class configuring enabling registration mkdir -p php-config/Emergence/People echo '<?php Emergence\\People\\RegistrationRequestHandler::$enableRegistration = true;' > php-config/Emergence/People/RegistrationRequestHandler.config.php # rebuild environment update-site After visiting /register and creating a new user account, you can use the studio command promote-user to upgrade the user account you just registered to the highest access level: promote-user <myuser> Connect to local database \u00b6 The studio container hosts a local MySQL instance that can be connected to at: Host : localhost (or LAN/WAN IP of machine hosting Docker engine) Port : 7136 Username : admin Password : admin","title":"Local Studio Container"},{"location":"development/getting-started/local-studio/#local-studio-container","text":"This guide will walk you through launching a Docker-container local development studio and using it to test changes made within a local Git repository.","title":"Local Studio Container"},{"location":"development/getting-started/local-studio/#launch-studio-container","text":"Install Chef Habitat: curl -s https://raw.githubusercontent.com/habitat-sh/habitat/master/components/hab/install.sh | sudo bash Set up Chef Habitat, accepting defaults for all prompts: hab setup Clone slate repository and any submodules: git clone --recursive git@github.com:SlateFoundation/slate.git Change into cloned directory: cd ./slate Launch studio: Use the included scripts-to-rules-them-all workflow script to configure and launch a studio session: script/studio Review the notes printed to your terminal at the end of the studio startup process for a list of all available studio commands.","title":"Launch studio container"},{"location":"development/getting-started/local-studio/#bootstrap-and-develop-backend","text":"Start services: Use the studio command start-all to launch the http server (nginx), the application runtime (php-fpm), and a local mysql server: start-all At this point, you should be able to open localhost:7180 and see the error message Page not found . Build site: To build the entire site and load it, use the studio command update-site : update-site At this point, localhost:7180 should display the current build of the site Load fixture data into site database (optional): load-fixtures The standard fixture data includes the following users: Username Password AccountLevel About system system Developer Full system access admin admin Administrator Manage site and staff teacher teacher Staff Staff access with teaching role in multiple courses sections teacher2 teacher2 Staff Staff access with teaching role in multiple course sections student student User Student user with student role in multiple course sections student2 student2 User Student user with student role in multiple course sections student3 student3 User Student user with no roles in any course sections Make and apply changes: After editing code in the working tree, you must rebuild and update the site: update-site A command to automatically rebuild and update the site as changes are made to the working tree is also available, but currently not that efficient or reliable: watch-site","title":"Bootstrap and develop backend"},{"location":"development/getting-started/local-studio/#enable-user-registration","text":"To enable user registration on a site that comes with it disabled: # write class configuring enabling registration mkdir -p php-config/Emergence/People echo '<?php Emergence\\People\\RegistrationRequestHandler::$enableRegistration = true;' > php-config/Emergence/People/RegistrationRequestHandler.config.php # rebuild environment update-site After visiting /register and creating a new user account, you can use the studio command promote-user to upgrade the user account you just registered to the highest access level: promote-user <myuser>","title":"Enable user registration"},{"location":"development/getting-started/local-studio/#connect-to-local-database","text":"The studio container hosts a local MySQL instance that can be connected to at: Host : localhost (or LAN/WAN IP of machine hosting Docker engine) Port : 7136 Username : admin Password : admin","title":"Connect to local database"},{"location":"development/getting-started/virtual-multisite/","text":"Virtual Multi-site Container \u00b6 Launch virtual multisite container \u00b6 docker run \\ --name emergence \\ -v emergence:/emergence \\ -p 80 :80 \\ -p 3306 :3306 \\ -p 9083 :9083 \\ jarvus/emergence","title":"Virtual Multi-site Container"},{"location":"development/getting-started/virtual-multisite/#virtual-multi-site-container","text":"","title":"Virtual Multi-site Container"},{"location":"development/getting-started/virtual-multisite/#launch-virtual-multisite-container","text":"docker run \\ --name emergence \\ -v emergence:/emergence \\ -p 80 :80 \\ -p 3306 :3306 \\ -p 9083 :9083 \\ jarvus/emergence","title":"Launch virtual multisite container"},{"location":"development/testing/e2e/","text":"End-to-end (E2E) testing \u00b6 Running tests \u00b6 Cypress is used to provide browser-level full-stack testing. The package.json file at the root of the repository specifies the dependencies for running the test suite and all the configuration/tests for Cypress are container in the cypress/ tree at the root of the repository. To get started, from a terminal outside the studio in the root of the repository: Install development tooling locally: npm install Launch the Cypress GUI: npm run cypress:open Testing against a remote server \u00b6 By setting environment variables before launching the Cypress GUI, the E2E test suite can be configured to execute against a backend studio hosted on a remote machine or server. On the local terminal outside the studio in the root of the repository: Set base URL to studo HTTP root reachable from local workstation: export CYPRESS_BASE_URL = 'http://workstation.mydomain:7080' Configure the SSH host that the backend studio is running on: export CYPRESS_STUDIO_SSH = 'workstation.mydomain' Your local terminal must be set up to connect to it without password. Configure the name of the Docker container running the backend studio: export CYPRESS_STUDIO_CONTAINER = 'skeleton-v2-studio' Launch the Cypress GUI: npm run cypress:open","title":"End-to-end (E2E) testing"},{"location":"development/testing/e2e/#end-to-end-e2e-testing","text":"","title":"End-to-end (E2E) testing"},{"location":"development/testing/e2e/#running-tests","text":"Cypress is used to provide browser-level full-stack testing. The package.json file at the root of the repository specifies the dependencies for running the test suite and all the configuration/tests for Cypress are container in the cypress/ tree at the root of the repository. To get started, from a terminal outside the studio in the root of the repository: Install development tooling locally: npm install Launch the Cypress GUI: npm run cypress:open","title":"Running tests"},{"location":"development/testing/e2e/#testing-against-a-remote-server","text":"By setting environment variables before launching the Cypress GUI, the E2E test suite can be configured to execute against a backend studio hosted on a remote machine or server. On the local terminal outside the studio in the root of the repository: Set base URL to studo HTTP root reachable from local workstation: export CYPRESS_BASE_URL = 'http://workstation.mydomain:7080' Configure the SSH host that the backend studio is running on: export CYPRESS_STUDIO_SSH = 'workstation.mydomain' Your local terminal must be set up to connect to it without password. Configure the name of the Docker container running the backend studio: export CYPRESS_STUDIO_CONTAINER = 'skeleton-v2-studio' Launch the Cypress GUI: npm run cypress:open","title":"Testing against a remote server"}]}